input {
  beats {
    port => 5044
  }

  http_poller {
    urls => {
      procedures_metadata => {
        method => get
        url => "http://localhost:8000/procedure-service/procedure/get?size=100"
        headers => { Accept => "application/json" }
        tags => ["metadata", "procedures"]
      }
      benches_metadata => {
        method => get
        url => "http://localhost:8000/bench-service/bench/get?size=100"
        headers => { Accept => "application/json" }
        tags => ["metadata", "benches"]
      }
    }
    request_timeout => 60
    schedule => { every => "5m" }
    codec => "json"
  }

  generator {
    lines => [ "trigger" ]
    count => -1
    tags => ["generate_requests"]
  }
}

filter {
  if "metadata" in [tags] {
    ruby {
      code => '
        procedures = event.get("[items]") || []
        benches = event.get("[items]") || []

        if event.get("[tags][1]") == "procedures"
          event.set("[@metadata][procedures]", procedures)
        elsif event.get("[tags][1]") == "benches"
          event.set("[@metadata][benches]", benches)
        end

        event.cancel
      '
    }
  }

  if "generate_requests" in [tags] {
    ruby {
      path => "/usr/share/logstash/config/scripts/generate_requests.rb"
    }

    split {
      field => "generated_requests"
    }

    mutate {
      add_field => {
        "type"                => "%{[generated_requests][type]}"
        "procedure_reference" => "%{[generated_requests][procedure_reference]}"
        "procedure_revision"  => "%{[generated_requests][procedure_revision]}"
        "bench_reference"     => "%{[generated_requests][bench_reference]}"
        "url"                 => "%{[generated_requests][url]}"
      }
    }

    ruby {
      code => '
        tags = event.get("[generated_requests][tags]") || []
        existing = event.get("tags") || []
        event.set("tags", (existing + tags).uniq)
      '
    }

    http {
      url => "%{[url]}"
      verb => "GET"
      headers => { Accept => "application/json" }
      target_body => "items"
    }
  }

  if "autorun_decide" in [tags] or "autorun_control" in [tags] {
    grok {
      match => [
        "message",
        "%{DATE:date} - %{TIME:time},%{INT:millis} - %{WORD:bench} - %{WORD:node} - %{WORD:type} - %{WORD:context} - %{GREEDYDATA:text}"
      ]
    }
  }

  else if "hil_synthesis_backend" in [tags] {
    grok {
      match => [
        "message",
        "%{DATE:date} - %{TIME:time},%{INT:millis} - %{WORD:system} - %{WORD:node} - %{WORD:type} - %{WORD:context} - %{GREEDYDATA:text}"
      ]
    }
  }

  else if "procedure_data" in [tags] {
    if [items] {
      split {
        field => "[items]"
        target => "item"
      }

      mutate {
        replace => { "message" => "%{[item]}" }
        remove_field => ["items", "total", "page", "size", "pages", "links"]

        add_field => {
          "type"                => "%{[item][type]}"
          "procedure_reference" => "%{[item][procedure_reference]}"
          "procedure_revision"  => "%{[item][procedure_revision]}"
          "bench_reference"     => "%{[item][bench_reference]}"
        }
      }
    }
  }
}

output {
  if "autorun_decide" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "hil-monitor-index"
    }
  }
  else if "autorun_control" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "hil-monitor-index"
    }
  }

  else if "hil_synthesis_backend" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "hil-monitor-index"
    }
  }

  else if "procedure_data" in [tags] {
    if [type] == "procedure" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "procedure-index"
        #document_id => "%{id}"
      }
    }
    else if [type] == "procedure_definition" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "procedure-definition-index"
        #document_id => "%{id}"
      }
    }
    else if [type] == "procedure_digitalization" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "procedure-digitalization-index"
        #document_id => "%{id}"
      }
    }
    else if [type] == "procedure_correlation" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "procedure-correlation-index"
        #document_id => "%{id}"
      }
    }
    else if [type] == "procedure_rating" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "procedure-rating-index"
        #document_id => "%{id}"
      }
    }
    else if [type] == "comment" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "comment-index"
        #document_id => "%{id}"
      }
    }
    else if [type] == "kpi_variable" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "kpi-variable-index"
        #document_id => "%{id}"
      }
    }
    else if [type] == "bench" {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "bench-index"
        #document_id => "%{id}"
      }
    }

    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "hil-synthesis-index-%{+YYYY.MM.dd}"
    }
  }

  stdout {
    codec => rubydebug
  }
}
